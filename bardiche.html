<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<script src="pixi.js"></script>
	<title>Bardiche</title>
</head>
	
<body style="background-color: #d95763;">

<div id="wrapper" style="display: flex; height: 100vh; justify-content: center; align-items: center;">
<div id="container" style="display: inline-block; width: 512px; height: 512px; margin-left: auto; margin-right: auto; border: thick solid #ac3232;"></div>
</div>
	<script type="text/javascript" src="keyboard.js"></script>
	<script type="text/javascript" src="collision.js"></script>

	<script type="text/javascript" src="player.js"></script>
	<script type="text/javascript" src="enemies.js"></script>
	<script type="text/javascript" src="levels.js"></script>

	<script type="text/javascript">

		// Timing
		let now = Date.now();
		let lastTime = now;
		let timeSinceLastFrame = 0;

		// Aliases
		let Container = PIXI.Container,
			autoDetectRenderer = PIXI.autoDetectRenderer,
			loader = PIXI.loader,
			resources = PIXI.loader.resources,
			Sprite = PIXI.Sprite,
			Text = PIXI.Text;

		// Pixi.js settings
		PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

		// Create the rendering environment and attach it to the page
		let stage = new Container(),   
			renderer = autoDetectRenderer(512, 512, {antialias: false});
		renderer.backgroundColor = 0x639BFF;
		document.getElementById("container").appendChild(renderer.view);
		
		// Load spritesheets
		loader.add("res/tiledata.json")
			.add("res/playerdata.json")
			.add("res/dummydata.json")
			.add("res/pumpkingdata.json")
			.add("res/nuttboydata.json")
			.add("res/background.png")
			.add("res/candlehouse.png")
			.add("res/candles.png")
			.load(setup);

		// Set initial game state
		let state = play;
		let screen = 0;

		/*
		 *  setup
		 *
		 *  intitializes sprites, hitboxes, keyboard callbacks
		 */
		let activeScreen;
		let player;

		let tileGroup;
		let keyObjectLeft, keyObjectRight, keyObjectZ, keyObjectX;
		let groundBoxes, hitBoxRenderer;
		let renderHitboxes;
		let backgroundSprite;
		function setup() {

			let tileTextures = PIXI.loader.resources["res/tiledata.json"].textures;
			let playerTextures = PIXI.loader.resources["res/playerdata.json"].textures;
			let dummyTextures = PIXI.loader.resources["res/dummydata.json"].textures;
			let kingTextures = PIXI.loader.resources["res/pumpkingdata.json"].textures;

			activeScreen = {
				stage: undefined,
				enemies: []
			};

			hitBoxRenderer = new PIXI.Graphics();
			renderHitboxes = false;

			backgroundSprite = new Sprite(resources["res/background.png"].texture);

			player = spawnPlayer(buildPlayer(playerBase_pinkKnight), 32, 384);

			setActiveScreen(screen);
			renderer.render(activeScreen.stage);

			keyObjectLeft = keyboard(37);
			keyObjectLeft.press = function() {
				if (player.controlMode === 'free') {
					if (player.weaponbox && player.activeWeaponbox.name ==='lunge') {
						if (player.sprite.scale.x === 1 && !player.grounded) player.sprite.vy -= 0.8;
					}
					player.sprite.scale.x = -1;
					if (player.stuck) {
						player.stuck = false;
						player.weaponbox = 0;
					}
				}
			}

			keyObjectRight = keyboard(39);
			keyObjectRight.press = function() {
				if (player.controlMode === 'free') {
					if (player.weaponbox && player.activeWeaponbox.name ==='lunge') {
						if (player.sprite.scale.x === -1 && !player.grounded) player.sprite.vy -= 0.8;
					}
					player.sprite.scale.x = 1;
					if (player.stuck) {
						player.stuck = false;
						player.weaponbox = 0;
					}
				}
			}

			keyObjectUp = keyboard(38);
			keyObjectUp.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) {
						player.grounded = false;
						player.sprite.vy = -5;
					} else if (player.stuck) {
						player.stuck = false;
						player.sprite.vy = -5;

						player.weaponbox = 0;
					}
				}
			}

			keyObjectZ = keyboard(90);
			keyObjectZ.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) {
						setAnimation(player.sprite, player.animations.stab, true);
						player.weaponbox = player.weaponBoxes.stab;
					}
					
					else {
						setAnimation(player.sprite, player.animations.lunge, true);
						player.weaponbox = player.weaponBoxes.lunge;
					}
				}				
			}
			keyObjectZ.release = function() {
				player.sprite.loop = false;
				player.sprite.onComplete = function() {
					setAnimation(player.sprite, player.animations.idle);
					player.stuck = false;
					player.weaponbox = 0;
				}
			}

			keyObjectX = keyboard(88);
			keyObjectX.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) {
						setAnimation(player.sprite, player.animations.slash, true);
						player.weaponbox = player.weaponBoxes.slash;
					}

					else {
						setAnimation(player.sprite, player.animations.drill);
						player.weaponbox = player.weaponBoxes.drill;
					}
				}				
			}
			keyObjectX.release = function() {
				player.sprite.loop = false;
				player.sprite.onComplete = function() {
					setAnimation(player.sprite, player.animations.idle);
					player.stuck = false;
					player.weaponbox = 0;
				}
			}

			keyObjectH = keyboard(72);
			keyObjectH.press = function() {
				renderHitboxes = renderHitboxes ? false : true;
			}


			eventBoxes.forEach(function(set) {
				set.forEach(function(box) {
					buildHitbox(box);
				});
			});

		}

		setAnimation = function(actor, frames, loop=true) {
			if (actor.textures != frames) {
				actor.textures = frames;
				actor.gotoAndPlay(0);
				actor.updateTexture();
			} 

			actor.loop = loop;
		}

		moveActor = function(actor, dx, dy) {
			actor.hitbox.centerX += dx;
			actor.hitbox.centerY += dy;

			actor.sprite.x += dx;
			actor.sprite.y += dy;
		}

		animatePlayer = function() {
			if (player.controlMode === 'free') {
				if (player.weaponbox) {

				} else {
					if (player.grounded) {
						if (player.sprite.vx === 0) setAnimation(player.sprite, player.animations.idle);
						else setAnimation(player.sprite, player.animations.walk);
					} else {
						setAnimation(player.sprite, player.animations.jump);
					}
				}
			} else if (player.controlMode === 'hit') {
				setAnimation(player.sprite, player.animations.damage);
			}
		}

		controlPlayer = function() {
			if (player.controlMode == 'free') {
				if (player.grounded && player.weaponbox) {
					player.sprite.vx = 0;
				} else {
					if (keyObjectRight.isDown && !keyObjectLeft.isDown) {
						player.sprite.vx = 2;
					} else if (keyObjectLeft.isDown && !keyObjectRight.isDown) {
						player.sprite.vx = -2;
					} else {
						player.sprite.vx = 0
					}
				}
			} else {
				if (player.grounded) {
					player.sprite.vx = 0;
					player.controlMode = 'free';
					setAnimation(player.sprite, player.animations.idle);
				}

				if (player.damageTimer < now - 1000) {
					player.controlMode = 'free';
					setAnimation(player.sprite, player.animations.idle);
				}
			}

			if (player.vulnerable === false && player.invulnTimer < now - 1000) {
				player.vulnerable = true;
			}
		}

		buildWeaponbox = function(actor, weaponboxBase) {
			let h = {
				name: weaponboxBase.name,

				x: actor.sprite.position.x + weaponboxBase.offsetX * actor.sprite.scale.x,
				y: actor.sprite.position.y + weaponboxBase.offsetY * actor.sprite.scale.y,

				width: weaponboxBase.width * actor.sprite.scale.x,
				height: weaponboxBase.height * actor.sprite.scale.y
			}

			buildHitbox(h);
			return h;
		}

		function buildStage(newScreen, enemies, playerSprite, scenery) {
			
			let tileTextures = PIXI.loader.resources["res/tiledata.json"].textures;
			let stage = new Container()

			groundBoxes = newScreen.groundBoxes;
			buildScreenBoxes(groundBoxes);
			
			stage.addChild(backgroundSprite);

			scenery.forEach(function(item) {
				console.log(item)
				let decoration = new Sprite(resources[item.path].texture);
				decoration.position.set(item.x, item.y);
				decoration.scale.set(2, 2);
				stage.addChild(decoration);
			});

			enemies.forEach(function(enemy) {
				stage.addChild(enemy.sprite);
			});

			stage.addChild(playerSprite);
			
			stage.addChild(getSpriteSet(tileTextures, newScreen.tiles));
			stage.addChild(hitBoxRenderer);

			return stage;
		}

		function setActiveScreen(key) {
			screen = key;
			let enemiesSrc = screens[key].enemies;
			activeScreen.enemies = [];
			enemiesSrc.forEach(function(enemy) {
				activeScreen.enemies.push(spawnEnemy(
					buildEnemy(enemy.name),
					enemy.position.x,
					enemy.position.y,
					enemy.spawnFunction
				));
			});

			activeScreen.stage = buildStage(screens[key], activeScreen.enemies, player.sprite, screenDecorations[key]);

		}

		function play() {
			hitBoxRenderer.clear();
			hitBoxRenderer.lineStyle(1, 0xFF0000);

			/* CHANGE SCREENS */
			if (player.sprite.x < 0) {

				moveActor(player, 512, 0);
				screen--;
				
				setActiveScreen(screen);
			
			} else if (player.sprite.x > 512) {

				moveActor(player, -512, 0);
				screen++;

				setActiveScreen(screen);
			}

			player.grounded = false;
			if (player.stuck) {
				player.sprite.vx = 0;
				player.sprite.vy = 0;
			}

			/* MOVE ACTORS */
			moveActor(player, player.sprite.vx, player.sprite.vy);

			activeScreen.enemies.forEach(function(enemy) {
				enemy.grounded = false;
				moveActor(enemy, enemy.sprite.vx, enemy.sprite.vy);

				manageEvent(enemy);
			});

			/* BUILD WEAPON HITBOXES */
			if (player.weaponbox) {
				player.activeWeaponbox = buildWeaponbox(player, player.weaponbox[player.sprite.currentFrame]);
			}

			activeScreen.enemies.forEach(function(enemy) {
				if (enemy.weaponbox) {
					enemy.activeWeaponbox = buildWeaponbox(enemy, enemy.weaponbox[enemy.sprite.currentFrame]);
				}
			});

			let collisionList;
			/* GROUND CHECKS */
			if (collisionList = getCollisions(player.hitbox, groundBoxes)) {
				collisionList.forEach(function(collision) {
					resolveCollision(player, collision);
				});
			}

			activeScreen.enemies.forEach(function(enemy) {
				if (collisionList = getCollisions(enemy.hitbox, groundBoxes)) {
					collisionList.forEach(function(collision) {
						resolveCollision(enemy, collision);
					});
				}

				if (!enemy.grounded) enemy.sprite.vy += 0.2;
			});

			/* WEAPON CHECKS */
			if (player.weaponbox) {
				if (collisionList = getCollisions(player.activeWeaponbox, groundBoxes)) {
					player.sprite.loop = false;
					player.sprite.onComplete = function() {
						player.stuck = true;
					}
				} else if (player.stuck) {
					player.stuck = false;
					player.weaponbox = 0;
				}

				activeScreen.enemies.forEach(function(enemy) {
					if (collisionList = getCollisions(player.activeWeaponbox, [enemy.hitbox])) {
						if (player.activeWeaponbox.name === 'drill') {
							player.sprite.vy = -1;
							if (enemy.vulnerable) {
								enemy.vulnerable = false;
								enemy.sprite.vx = 0;
								setAnimation(enemy.sprite, enemy.animations.walk, true);
								pushEvent(enemy, {
									run(enemy) {
										setAnimation(enemy.sprite, enemy.animations.attack2, false);
										enemy.weaponbox = 0;
										enemy.sprite.onComplete = function() {
											enemy.vulnerable = true;

											nuttboyCharge(enemy, player);
										}
									},

									delay: 250
								});
							}
						}
					}
				});
			}

			activeScreen.enemies.forEach(function(enemy) {
				if (enemy.weaponbox) {
					if (enemy.activeWeaponbox.name === 'stab') {
						if (collisionList = getCollisions(enemy.activeWeaponbox, groundBoxes)) {
							setAnimation(enemy.sprite, enemy.animations.stuck);
							enemy.weaponbox = 0;

							pushEvent(enemy, {
								run(enemy) {
									setAnimation(enemy.sprite, enemy.animations.stuck, true);
									enemy.sprite.vx = 0;
								},

								delay: 50
							});

							pushEvent(enemy, {
								run(enemy) {
									setAnimation(enemy.sprite, enemy.animations.attack2, false);
									enemy.sprite.onComplete = function() {
										setAnimation(enemy.sprite, enemy.animations.attack1);
										enemy.sprite.scale.x = enemy.sprite.scale.x * -1;
										enemy.sprite.vx = enemy.sprite.scale.x * 4;
										enemy.weaponbox = enemy.weaponBoxes.attack1;
									}
								},

								delay: 1000
							});
						}

						if (player.vulnerable) {
							if (collisionList = getCollisions(enemy.activeWeaponbox, [player.hitbox])) {
								enemy.sprite.vx = 0;
								damagePlayer(player, 1);
								player.sprite.vx = enemy.sprite.scale.x * 5;
								player.sprite.vy = -3;

								enemy.eventQueue = [];
								pushEvent(enemy, {
									run(enemy) {
										nuttboyCharge(enemy, player);
									},

									delay: 1000
								});
							}
						}
					}
				}
			});

			/* GRAVITY */
			if (!player.grounded && !player.stuck) player.sprite.vy += 0.2;

			/* RENDER HITBOXES */
			if (renderHitboxes) {
				groundBoxes.forEach(function(box) {
					hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
				});

				drawHitbox(player.hitbox, hitBoxRenderer)
				if (player.weaponbox) {
					let box = player.activeWeaponbox;
					hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
				}

				activeScreen.enemies.forEach(function(enemy) {
					drawHitbox(enemy.hitbox, hitBoxRenderer);

					if (enemy.weaponbox) {
						let box = enemy.activeWeaponbox;
						hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
					}
				});
			}

			eventBoxes[screen].forEach(function(box) {
				if (box.active) {
					let collision = rectangleCollision(player.hitbox, box);
					if (!box.playerPresent && collision) {
						box.onPlayerEnter();
					} else if (box.playerPresent && collision == undefined) {
						box.playerPresent = false;
					}

					if (renderHitboxes) hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
				}
			});

			/* CONTROL AND ANIMATE PLAYER */
			controlPlayer();
			animatePlayer();
		}

		function gameLoop() {
			now = Date.now();
			timeSinceLastFrame = now - lastTime;

			requestAnimationFrame(gameLoop);
			state();
			renderer.render(activeScreen.stage);

			lastTime = now;
		}

		gameLoop();

	</script>
</body>
</html>
