<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<script src="pixi.js"></script>
	<title>Bardiche</title>
</head>
	
<body style="background-color: #d95763;">

<div id="wrapper" style="display: flex; height: 100vh; justify-content: center; align-items: center;">
<div id="container" style="display: inline-block; width: 512px; height: 512px; margin-left: auto; margin-right: auto; border: thick solid #ac3232;"></div>
</div>
	<script type="text/javascript" src="keyboard.js"></script>
	<script type="text/javascript" src="collision.js"></script>

	<script type="text/javascript" src="platform.js"></script>
	<script type="text/javascript" src="player.js"></script>
	<script type="text/javascript" src="enemies.js"></script>
	<script type="text/javascript" src="levels.js"></script>

	<script type="text/javascript">

		// Timing
		let now = Date.now();
		let lastTime = now;
		let timeSinceLastFrame = 0;

		// Aliases
		let Container = PIXI.Container,
			autoDetectRenderer = PIXI.autoDetectRenderer,
			loader = PIXI.loader,
			resources = PIXI.loader.resources,
			Sprite = PIXI.Sprite,
			Text = PIXI.Text;

		// Pixi.js settings
		PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

		// Create the rendering environment and attach it to the page
		let stage = new Container(),   
			renderer = autoDetectRenderer(512, 512, {antialias: false});
		renderer.backgroundColor = 0x639BFF;
		document.getElementById("container").appendChild(renderer.view);
		
		// Load spritesheets
		loader.add('res/grasstiles.json')
			.add('res/playerdata.json')
			.add('res/skeleton-data.json')
			.add('res/bigtree.png')
			.add('res/climbtree.png')
			.add('res/climbtree-bg.png')
			.add('res/goddess.png')
			.add('res/cloudscroll.png')
			.add('res/marble.png')
			.add('res/mountainscroll-1.png')
			.add('res/mountainscroll-2.png')
			.add('res/treescroll.png')
			.load(setup);

		// Set initial game state
		let state = play;

		/*
		 *  setup
		 *
		 *  intitializes sprites, hitboxes, keyboard callbacks
		 */
		let activeScreen;
		let player;

		let tileGroup;
		let keyObjectLeft, keyObjectRight, keyObjectZ, keyObjectX;
		let groundBoxes, hitBoxRenderer;
		let renderHitboxes;
		let cloudsSprite, cloudsSprite2;
		function setup() {

			let tileTextures = PIXI.loader.resources["res/grasstiles.json"].textures;
			let playerTextures = PIXI.loader.resources["res/playerdata.json"].textures;

			cloudsSprite = new PIXI.extras.TilingSprite(resources['res/cloudscroll.png'].texture, 256, 256);
			cloudsSprite.scale.set(2, 2);
			cloudsSprite.position.set(0, 0);

			cloudsSprite2 = new PIXI.extras.TilingSprite(resources['res/cloudscroll.png'].texture, 256, 256);
			cloudsSprite2.scale.set(2, 2);
			cloudsSprite2.position.set(0, -128);
			cloudsSprite2.tilePosition.set(256, 0);

			hitBoxRenderer = new PIXI.Graphics();
			renderHitboxes = true;

			player = spawnPlayer(buildPlayer(playerBase_pinkKnight), 256, 320);

			activeScreen = {};
			setActiveScreen(level_forest);
			renderer.render(activeScreen.stage); 

			keyObjectLeft = keyboard(37);
			keyObjectLeft.press = function() {
				if (player.sprite.scale.x === 1 && keyObjectZ.isDown) {
					player.sprite.vy -= 0.8;
				}

				if (player.controlMode === 'stuck') {
					player.controlMode = 'free';
					player.weaponbox = 0;
				}
			}
			keyObjectRight = keyboard(39);
			keyObjectRight.press = function() {
				if (player.sprite.scale.x === -1 && keyObjectZ.isDown) {
					player.sprite.vy -= 0.8;
				}

				if (player.controlMode === 'stuck') {
					player.controlMode = 'free';
					player.weaponbox = 0;
				}
			}

			keyObjectZ = keyboard(90);
			keyObjectZ.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) attackPlayer(player, 'stab');
					else attackPlayer(player, 'lunge');
				}
			}
			keyObjectZ.release = function() {
				if (!keyObjectX.isDown) {
					player.sprite.loop = false;
					player.sprite.onComplete = function() {
						player.controlMode = 'free';
						setAnimation(player, player.animations.idle);
						player.weaponbox = 0;
					}
				}
			}

			keyObjectX = keyboard(88);
			keyObjectX.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) attackPlayer(player, 'slash');
					else {
						attackPlayer(player, 'drill');
						player.sprite.vy = 8;
					}
				}
			}
			keyObjectX.release = function() {
				if (!keyObjectZ.isDown) {
					player.sprite.loop = false;
					player.sprite.onComplete = function() {
						setAnimation(player, player.animations.idle);
						player.weaponbox = 0;
					}
				}
			}

			keyObjectH = keyboard(72);
			keyObjectH.press = function() {
				renderHitboxes = renderHitboxes ? false : true;
			}


			eventBoxes.forEach(function(set) {
				set.forEach(function(box) {
					buildHitbox(box);
				});
			});
		}

		setAnimation = function(actor, frames, loop=true) {
			if (actor.sprite.textures != frames) {
				actor.sprite.textures = frames;
				actor.sprite.gotoAndPlay(0);
				actor.sprite.updateTexture();
			} 

			actor.sprite.loop = loop;
		}

		moveActor = function(actor, dx, dy, isFocus=false) {
			actor.hitbox.centerX += dx;
			actor.hitbox.centerY += dy;

			if (!isFocus) {
				actor.sprite.x += dx;
				actor.sprite.y += dy;
			}

			if (actor.footLine) moveLine(actor.footLine, dx, dy);
		}

		buildWeaponbox = function(actor, weaponboxBase) {
			let h = {
				name: weaponboxBase.name,

				x: actor.sprite.position.x + weaponboxBase.offsetX * actor.sprite.scale.x,
				y: actor.sprite.position.y + weaponboxBase.offsetY * actor.sprite.scale.y,

				width: weaponboxBase.width * actor.sprite.scale.x,
				height: weaponboxBase.height * actor.sprite.scale.y
			}

			buildHitbox(h);
			return h;
		}

		function buildStage(level, playerSprite) {
			
			let tileTextures = PIXI.loader.resources["res/grasstiles.json"].textures;
			let stage = new Container()

			stage.addChild(cloudsSprite);
			stage.addChild(cloudsSprite2);

			level.background.forEach(function(item) {
				let scrollSprite = new PIXI.extras.TilingSprite(resources[item.path].texture, 256, 256);
				scrollSprite.scrollRate = item.scrollRate;
				scrollSprite.scale.set(2, 2);
				stage.addChild(scrollSprite);
				activeScreen.background.push(scrollSprite);
			});

			level.scenery.forEach(function(item) {
				let newSprite = new Sprite(resources[item.path].texture);
				newSprite.position.set(item.x, item.y);
				newSprite.scale.set(2, 2);
				stage.addChild(newSprite);
				activeScreen.scenery.push(newSprite);
			});

			level.enemies.forEach(function(enemy) {
				let newEnemy = spawnEnemy(buildEnemy(enemy.base), enemy.x, enemy.y);
				activeScreen.enemies.push(newEnemy);
				stage.addChild(newEnemy.sprite);
			});
			
			stage.addChild(playerSprite);

			level.platformGroups[0].platforms.forEach(function(platform) {
				setPlatformTiles(tileTextures, platform);
				stage.addChild(platform.backgroundGroup);
				stage.addChild(platform.tileGroup);

				if (platform.type === 'block') {
					buildHitbox(platform.hitbox);
				}
			});
			
			stage.addChild(hitBoxRenderer);

			let testText = new PIXI.Text('this is some example text!', {fontFamily: 'Arial', fontSize: 24, fill: 0x330011, align: 'center'
				, wordWrap: true, wordWrapWidth: 256});
			stage.addChild(testText)
 
			return stage;
		}

		function setActiveScreen(level) {
			activeScreen.platforms = level.platformGroups[0].platforms;
			activeScreen.background = [];
			activeScreen.scenery = [];
			activeScreen.enemies = [];
			activeScreen.stage = buildStage(level, player.sprite);
		}

		function play() {

			hitBoxRenderer.clear();
			hitBoxRenderer.lineStyle(1, 0xFF0000);

			/* CLOUD SCROLL */
			cloudsSprite.tilePosition.x -= 0.01;
			cloudsSprite2.tilePosition.x -= 0.05;

			if (player.grounded) player.sprite.vy = 0.1;
			player.grounded = false;

			/* MOVE ACTORS */
			movePlayer(player, player.sprite.vx, player.sprite.vy);
			activeScreen.enemies.forEach(function(enemy) {
				moveActor(enemy, enemy.sprite.vx, enemy.sprite.vy);
				enemy.onstep();
			});
			/* BUILD WEAPON HITBOXES */
			if (player.weaponbox) {
				player.activeWeaponbox = buildWeaponbox(player, player.weaponbox[player.sprite.currentFrame]);
			}

			/* GROUND CHECKS */
			let collision, collisionList;
			activeScreen.platforms.forEach(function(platform) {
				collision = 0;

				if (platform.type === 'platform') {
					if (!player.keyObjectDown.isDown && player.sprite.vy > 0) {
						collision = linesCross(player.footLine, platform);
					}
				} else if (platform.type === 'block') {
					collision = rectangleCollision(player.hitbox, platform.hitbox);
				}

				if (collision) {
						if (platform.tileGroup.children.length > 0) {
							
							activeScreen.stage.removeChild(player.sprite);
							activeScreen.stage.addChildAt(player.sprite, activeScreen.stage.getChildIndex(platform.tileGroup));

							player.activePlatform = platform;
						}

						player.resolveCollision(collision);
					}

				activeScreen.enemies.forEach(function(enemy) {
					collision = 0;

					if (platform.type === 'platform') {
						collision = linesCross(enemy.footLine, platform);
					} else if (platform.type === 'block') {
						collision = rectangleCollision(enemy.hitbox, platform.hitbox);
					}

					if (collision) {
							if (platform.tileGroup.children.length > 0) {
								
								activeScreen.stage.removeChild(enemy.sprite);
								activeScreen.stage.addChildAt(enemy.sprite, activeScreen.stage.getChildIndex(platform.tileGroup));

								enemy.activePlatform = platform;
							}

							enemy.resolveCollision(collision);
						}
				})
			});

			/* GRAVITY */
			if (!player.grounded && !player.stuck) {
				let t = player.jumptimer;

				if (player.sprite.vy < player.terminalVelocity) player.sprite.vy += 0.2 - 0.2 * (player.jumptimer/20);

				if (player.jumptimer > 0) player.jumptimer--;
			}


			activeScreen.enemies.forEach(function(enemy) {
				if (!enemy.grounded) enemy.sprite.vy += 0.2;
			});

			/* RENDER HITBOXES */
			if (renderHitboxes) {

				hitBoxRenderer.moveTo(player.footLine.p1.x, player.footLine.p1.y);
				hitBoxRenderer.lineTo(player.footLine.p2.x, player.footLine.p2.y);

				activeScreen.platforms.forEach(function(platform) {
					if (platform.type === 'platform') {
						hitBoxRenderer.moveTo(platform.p1.x - player.hitbox.centerX + 256, platform.p1.y - player.hitbox.centerY + 320);
						hitBoxRenderer.lineTo(platform.p2.x - player.hitbox.centerX + 256, platform.p2.y - player.hitbox.centerY + 320);
					} else if (platform.type === 'block') {
						drawHitbox(platform.hitbox, hitBoxRenderer);
					}
				});

				activeScreen.enemies.forEach(function(enemy) {
					drawHitbox(enemy.hitbox, hitBoxRenderer)
				});

				drawHitbox(player.hitbox, hitBoxRenderer)
				if (player.weaponbox) {
					let box = player.activeWeaponbox;
					hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
				}
			}

			/* CONTROL AND ANIMATE PLAYER */
			controlPlayer();
			animatePlayer();
		}

		function gameLoop() {
			now = Date.now();
			timeSinceLastFrame = now - lastTime;

			requestAnimationFrame(gameLoop);
			state();
			renderer.render(activeScreen.stage);

			lastTime = now;
		}

		gameLoop();

	</script>
</body>
</html>
