<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Bardiche</title>
</head>
	<script src="pixi.js"></script>
	
<body style="background-color: #d95763">

<div id="container" style="width: 512px; height: 512px; margin-left: auto; margin-right: auto; border: thick solid #ac3232;"></div>

	<script src="keyboard.js"></script>
	<script src="collision.js"></script>
	<script type="text/javascript">

		//Aliases
		let Container = PIXI.Container,
			autoDetectRenderer = PIXI.autoDetectRenderer,
			loader = PIXI.loader,
			resources = PIXI.loader.resources,
			Sprite = PIXI.Sprite,
			Text = PIXI.Text;

		PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

		let stage = new Container(),
			renderer = autoDetectRenderer(512, 512, {antialias: false});
		renderer.backgroundColor = 0x639BFF;
		document.getElementById("container").appendChild(renderer.view);
		
		loader.add("res/tiledata.json")
			.add("res/playerdata.json")
			.add("res/dummydata.json")
			.load(setup);

		let state = play;

		let tileSrc, tiles, tileGroup;
		let keyObjectLeft, keyObjectRight, keyObjectZ, keyObjectX;
		let groundBoxes, hitBoxRenderer;
		let playerWalkFrames, playerIdleFrames, playerJumpFrames, playerStabFrames, playerSlashFrames;
		let dummyIdleFrames, dummyHitFrames;

		function setup() {
			let tileTextures = PIXI.loader.resources["res/tiledata.json"].textures;
			let playerTextures = PIXI.loader.resources["res/playerdata.json"].textures;
			let dummyTextures = PIXI.loader.resources["res/dummydata.json"].textures;

			let tileEnum = {
				FIL_AIR: 0,

				STR_BOT: 1,
				STR_TOP: 2,
				STR_LEF: 3,
				STR_RIG: 4,

				CRN_ITR: 5,
				CRN_ITL: 6,
				CRN_IBR: 7,
				CRN_IBL: 8,

				CRN_OTR: 9,
				CRN_OTL: 10,
				CRN_OBR: 11,
				CRN_OBL: 12,

				FIL_DRT: 13
			};

			tileSrc = [[tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.CRN_OTL, tileEnum.CRN_IBR, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT],
					   [tileEnum.FIL_AIR, tileEnum.CRN_OTL, tileEnum.STR_BOT, tileEnum.CRN_IBR, tileEnum.CRN_ITL, tileEnum.STR_TOP, tileEnum.STR_TOP, tileEnum.STR_TOP],
					   [tileEnum.FIL_AIR, tileEnum.CRN_OBL, tileEnum.STR_TOP, tileEnum.STR_TOP, tileEnum.CRN_OBR, tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.FIL_AIR],
					   [tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.FIL_AIR, tileEnum.CRN_OTL, tileEnum.STR_BOT, tileEnum.STR_BOT],
					   [tileEnum.STR_BOT, tileEnum.STR_BOT, tileEnum.STR_BOT, tileEnum.STR_BOT, tileEnum.STR_BOT, tileEnum.CRN_IBR, tileEnum.FIL_DRT, tileEnum.FIL_DRT],
					   [tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT],
					   [tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT],
					   [tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT, tileEnum.FIL_DRT]];

			tiles = [[0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0],
					 [0, 0, 0, 0, 0, 0, 0, 0]];

			tileGroup = new Container();
			for (let i = 0; i < tileSrc.length; i++) {
				for (let j = 0; j < tileSrc[i].length; j++) {
					if (tileSrc[i][j] != 0) {
						switch (tileSrc[i][j]) {
							case tileEnum.STR_BOT: tiles[i][j] = new Sprite(tileTextures["bottom.png"]); break;
							case tileEnum.STR_TOP: tiles[i][j] = new Sprite(tileTextures["top.png"]); break;
							case tileEnum.STR_LEF: tiles[i][j] = new Sprite(tileTextures["left.png"]); break;
							case tileEnum.STR_RIG: tiles[i][j] = new Sprite(tileTextures["right.png"]); break;

							case tileEnum.CRN_OBL: tiles[i][j] = new Sprite(tileTextures["outside-bl.png"]); break;
							case tileEnum.CRN_OBR: tiles[i][j] = new Sprite(tileTextures["outside-br.png"]); break;
							case tileEnum.CRN_OTL: tiles[i][j] = new Sprite(tileTextures["outside-tl.png"]); break;
							case tileEnum.CRN_OTR: tiles[i][j] = new Sprite(tileTextures["outside-tr.png"]); break;

							case tileEnum.CRN_IBL: tiles[i][j] = new Sprite(tileTextures["inside-bl.png"]); break;
							case tileEnum.CRN_IBR: tiles[i][j] = new Sprite(tileTextures["inside-br.png"]); break;
							case tileEnum.CRN_ITL: tiles[i][j] = new Sprite(tileTextures["inside-tl.png"]); break;
							case tileEnum.CRN_ITR: tiles[i][j] = new Sprite(tileTextures["inside-tr.png"]); break;

							case tileEnum.FIL_DRT: tiles[i][j] = new Sprite(tileTextures["fill.png"]); break;
						}

						tiles[i][j].position.set(j*64, i*64);
						tileGroup.addChild(tiles[i][j]);
					}
				}
			}

			groundBoxes = [{x: 0, y: 288, width: 352, height: 32},
						   {x: 352, y: 224, width: 160, height: 96},
						   {x: 96, y: 96, width: 192, height: 64}];

			for (let i=0; i<groundBoxes.length; i++) {
				let box = groundBoxes[i];

				box.halfWidth = box.width / 2;
				box.halfHeight = box.height / 2;
				box.centerX = box.x + box.halfWidth;
				box.centerY = box.y + box.halfHeight;
				
			}

			dummyIdleFrames = []
			dummyHitFrames = []

			dummyIdleFrames.push(PIXI.Texture.fromFrame("dummy-stand.png"));
			dummyIdleFrames.push(PIXI.Texture.fromFrame("dummy-stand.png"));

			dummyHitFrames.push(PIXI.Texture.fromFrame("dummy-hit-1.png"));
			dummyHitFrames.push(PIXI.Texture.fromFrame("dummy-hit-2.png"));

			dummySprite = new PIXI.extras.AnimatedSprite(dummyIdleFrames);
			dummySprite.animationSpeed = 0.05;
			dummySprite.play();
			dummySprite.anchor.x = 0.5;
			dummySprite.x = 96;
			dummySprite.y = 192;

			dummySprite.hitbox = {
				x: dummySprite.x - dummySprite.width/6,
				y: dummySprite.y + dummySprite.height/4,
				width: dummySprite.width/3,
				height: dummySprite.height/2,

				halfWidth: dummySprite.width/6,
				halfHeight: dummySprite.height/4,
				centerX: dummySprite.x,
				centerY: dummySprite.y + dummySprite.height/2
			}

			playerWalkFrames = []
			playerIdleFrames = []
			playerJumpFrames = []
			playerStabFrames = []
			playerSlashFrames = []

			playerWalkFrames.push(PIXI.Texture.fromFrame("pink-knight-walk-1.png"));
			playerWalkFrames.push(PIXI.Texture.fromFrame("pink-knight-walk-2.png"));

			playerIdleFrames.push(PIXI.Texture.fromFrame("pink-knight-stand.png"));
			playerIdleFrames.push(PIXI.Texture.fromFrame("pink-knight-stand.png"));

			playerJumpFrames.push(PIXI.Texture.fromFrame("pink-knight-walk-2.png"));
			playerJumpFrames.push(PIXI.Texture.fromFrame("pink-knight-walk-2.png"));

			playerStabFrames.push(PIXI.Texture.fromFrame("pink-knight-stab-1.png"));
			playerStabFrames.push(PIXI.Texture.fromFrame("pink-knight-stab-1.png"));
			playerStabFrames.push(PIXI.Texture.fromFrame("pink-knight-stab-2.png"));
			playerStabFrames.push(PIXI.Texture.fromFrame("pink-knight-stab-2.png"));

			playerSlashFrames.push(PIXI.Texture.fromFrame("pink-knight-slash-1.png"));
			playerSlashFrames.push(PIXI.Texture.fromFrame("pink-knight-slash-1.png"));
			playerSlashFrames.push(PIXI.Texture.fromFrame("pink-knight-slash-2.png"));
			playerSlashFrames.push(PIXI.Texture.fromFrame("pink-knight-slash-2.png"));

			playerSprite = new PIXI.extras.AnimatedSprite(playerWalkFrames);
			playerSprite.position.set(192, 100);
			playerSprite.grounded = false;
			playerSprite.centerX = playerSprite.x;
			playerSprite.centerY = playerSprite.y + playerSprite.height / 2;
			playerSprite.vx = 0;
			playerSprite.vy = 0;

			playerSprite.animationSpeed = 0.1;
			playerSprite.play();

			playerSprite.anchor.x = 0.5;

			playerSprite.hitbox = {x: playerSprite.x - 16,
								   y: playerSprite.y + 32,
								   width: 32,
								   height: 64,
								   halfWidth: 16,
								   halfHeight: 32
								   };

			playerSprite.hitbox.centerY = playerSprite.hitbox.y + playerSprite.hitbox.halfHeight;
			playerSprite.hitbox.centerX = playerSprite.x;

			playerSprite.weaponbox = 0;

			hitBoxRenderer = new PIXI.Graphics();
			
			stage.addChild(dummySprite);
			stage.addChild(playerSprite);
			stage.addChild(tileGroup);
			stage.addChild(hitBoxRenderer);
			renderer.render(stage);

			keyObjectRight = keyboard(39);

			keyObjectRight.press = function() {
				playerSprite.vx += 2;

				setPlayerAnimation(playerWalkFrames);
			}
			keyObjectRight.release = function() {
				if (playerSprite.vx === 2) playerSprite.vx = 0;
			}

			keyObjectLeft = keyboard(37);
			keyObjectLeft.press = function() {
				playerSprite.vx -= 2;

				setPlayerAnimation(playerWalkFrames);
			}
			keyObjectLeft.release = function() {
				if (playerSprite.vx === -2) playerSprite.vx = 0;
			}

			keyObjectUp = keyboard(38);
			keyObjectUp.press = function() {
				if (playerSprite.grounded) {
					playerSprite.grounded = false;
					playerSprite.vy = -5;
				}
			}

			keyObjectZ = keyboard(90);
			keyObjectZ.press = function() {
				setPlayerAnimation(playerStabFrames, true);

				playerSprite.weaponbox = [{
					offsetX: 6,
					offsetY: 72,

					width: 32,
					height: 16
				}, {
					offsetX: 20,
					offsetY: 72,

					width: 32,
					height: 16,
				}]
			}
			keyObjectZ.release = function() {
				playerSprite.loop = false;
				playerSprite.onComplete = function() {
					setPlayerAnimation(playerIdleFrames);
					playerSprite.weaponbox = 0;
				}
			}

			keyObjectX = keyboard(88);
			keyObjectX.press = function() {
				setPlayerAnimation(playerSlashFrames, true);

				playerSprite.weaponbox = [{
					offsetX: 14,
					offsetY: 32,

					width: 16,
					height: 32
				}, {
					offsetX: 20,
					offsetY: 72,

					width: 32,
					height: 16,
				}]
			}
			keyObjectX.release = function() {
				playerSprite.loop = false;
				playerSprite.onComplete = function() {
					setPlayerAnimation(playerIdleFrames);
					playerSprite.weaponbox = 0;
				}
			}
		}

		function setPlayerAnimation(frames, loop=true) {
			if (playerSprite.textures != frames) {
				playerSprite.textures = frames;
				playerSprite.gotoAndPlay(0);
			}

			playerSprite.loop = loop;
		}

		function moveActor(A, collision) {

			console.log("side: " + collision.side + ", overlap: " + collision.overlap);

			if (collision.side == "top") {
				A.y = A.y + collision.overlap;
				A.centerY = A.centerY + collision.overlap;

				if (A.hitbox) {
					A.hitbox.y = A.hitbox.y + collision.overlap;
					A.hitbox.centerY = A.hitbox.centerY + collision.overlap;
				}
			} else if (collision.side == "bottom") {
				A.y = A.y - collision.overlap;
				A.centerY = A.centerY - collision.overlap;

				if (A.hitbox) {
					A.hitbox.y = A.hitbox.y - collision.overlap;
					A.hitbox.centerY = A.hitbox.centerY - collision.overlap;
				}
			} else if (collision.side == "left") {
				A.x = A.x + collision.overlap;
				A.centerX = A.centerX + collision.overlap;

				if (A.hitbox) {
					A.hitbox.X = A.hitbox.X + collision.overlap;
					A.hitbox.centerX = A.hitbox.centerX + collision.overlap;
				}
			} else if (collision.side == "right") {
				A.x = A.x - collision.overlap;
				A.centerX = A.centerX - collision.overlap;

				if (A.hitbox) {
					A.hitbox.x = A.hitbox.x - collision.overlap;
					A.hitbox.centerX = A.hitbox.centerX - collision.overlap;
				}
			} 
		}

		function rectangleCollision(r1, r2) {

		    let side, overlap, combinedHalfWidths, combinedHalfHeights, overlapX, overlapY, vx, vy;

		    vx = r1.centerX - r2.centerX;
		    vy = r1.centerY - r2.centerY;

		    combinedHalfWidths = Math.abs(r1.halfWidth) + Math.abs(r2.halfWidth);
		    combinedHalfHeights = Math.abs(r1.halfHeight) + Math.abs(r2.halfHeight);

		    if (Math.abs(vx) < combinedHalfWidths) {

		    	if (Math.abs(vy) < combinedHalfHeights) {

			        overlapX = combinedHalfWidths - Math.abs(vx);
			        overlapY = combinedHalfHeights - Math.abs(vy);

			        if (overlapX >= overlapY) {

			        	if (vy > 0) {
			        		side = "top";
			        		overlap = overlapY;
						} else {
			            	side = "bottom";
			            	overlap = overlapY;
			        	}
			        } else {
						if (vx > 0) {
				        	side = "left";
				        	overlap = overlapX;
			        	} else {
				            side = "right";
				            overlap = overlapX;
			    		}
			        }
			    } else {
			        //No collision
			    }
		    } else {
		      //No collision
		    }

			return {side: side, overlap: overlap};
		}

		function play() {
			hitBoxRenderer.clear();
			hitBoxRenderer.lineStyle(1, 0xFF0000);

			playerSprite.x += playerSprite.vx;
			playerSprite.y += playerSprite.vy;

			playerSprite.centerX += playerSprite.vx;
			playerSprite.centerY += playerSprite.vy;

			playerSprite.hitbox.x += playerSprite.vx;
			playerSprite.hitbox.y += playerSprite.vy;
			playerSprite.hitbox.centerX += playerSprite.vx;
			playerSprite.hitbox.centerY += playerSprite.vy;



			let activeWeaponbox = 0;
			if (playerSprite.weaponbox != 0) {
				let box = playerSprite.weaponbox[Math.floor(playerSprite.currentFrame/2)];
				activeWeaponbox = {
					halfWidth: box.width/2,
					halfHeight: box.height/2,

					centerX: playerSprite.x + (box.width/2 + box.offsetX)*playerSprite.scale.x,
					centerY: playerSprite.y + (box.height/2 + box.offsetY)
				}
			}

			for (let i=0; i<groundBoxes.length; i++) {
				let box = groundBoxes[i];
				let collision = rectangleCollision(playerSprite.hitbox, box)
				if (collision.side) {
					
					moveActor(playerSprite, coll);
					if(collision.side == "bottom") {
						playerSprite.vy = 0;
						playerSprite.grounded = true;
					}

					;
				}

				//hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
			}

			
			if (activeWeaponbox != 0) {
				let collision = rectangleCollision(activeWeaponbox, dummySprite.hitbox);
				if (collision.side) {
					dummySprite.textures = dummyHitFrames;
					dummySprite.gotoAndPlay(1 - Math.floor(playerSprite.currentFrame/2));
				} else {
					dummySprite.textures = dummyIdleFrames;
					dummySprite.gotoAndPlay(1);
				}
			} else {
				dummySprite.textures = dummyIdleFrames;
				
			}console.log("aftr");



			if (playerSprite.grounded) {
				if (playerSprite.textures === playerJumpFrames) {
					setPlayerAnimation(playerIdleFrames);
				}
			} else if (activeWeaponbox === 0 && playerSprite.textures != playerJumpFrames) {
				playerSprite.textures = playerJumpFrames;
			}

			if (playerSprite.vx < 0 && playerSprite.scale.x === 1) {
				playerSprite.scale.x = -1;
			} else if (playerSprite.vx > 0 && playerSprite.scale.x === -1) {
				playerSprite.scale.x = 1;
			}

			if (playerSprite.vx === 0 && playerSprite.textures === playerWalkFrames) {
				setPlayerAnimation(playerIdleFrames, true)
			} else if (playerSprite.vx != 0 && playerSprite.textures === playerIdleFrames) {
				setPlayerAnimation(playerWalkFrames, true);
			}

			//Check inputs!
			if ((keyObjectZ.isDown || keyObjectX.isDown) && playerSprite.grounded) {
				playerSprite.vx = 0;
			} else if (keyObjectLeft.isDown && !keyObjectRight.isDown) {
				playerSprite.vx = -2;
			} else if (keyObjectRight.isDown && !keyObjectLeft.isDown) {
				playerSprite.vx = 2;
			}

			playerSprite.vy += 0.2;
		}

		function gameLoop() {
			requestAnimationFrame(gameLoop);
			state();
			renderer.render(stage);
		}

		gameLoop();

	</script>
</body>
</html>
