<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<script src="pixi.js"></script>
	<title>Bardiche</title>
</head>
	
<body style="background-color: #d95763;">

<div id="wrapper" style="display: flex; height: 100vh; justify-content: center; align-items: center;">
<div id="container" style="display: inline-block; width: 512px; height: 512px; margin-left: auto; margin-right: auto; border: thick solid #ac3232;"></div>
</div>
	<script type="text/javascript" src="keyboard.js"></script>
	<script type="text/javascript" src="collision.js"></script>

	<script type="text/javascript" src="platform.js"></script>
	<script type="text/javascript" src="player.js"></script>
	<script type="text/javascript" src="enemies.js"></script>
	<script type="text/javascript" src="levels.js"></script>

	<script type="text/javascript">

		// Timing
		let now = Date.now();
		let lastTime = now;
		let timeSinceLastFrame = 0;

		// Aliases
		let Container = PIXI.Container,
			autoDetectRenderer = PIXI.autoDetectRenderer,
			loader = PIXI.loader,
			resources = PIXI.loader.resources,
			Sprite = PIXI.Sprite,
			Text = PIXI.Text;

		// Pixi.js settings
		PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;

		// Create the rendering environment and attach it to the page
		let stage = new Container(),   
			renderer = autoDetectRenderer(512, 512, {antialias: false});
		renderer.backgroundColor = 0x639BFF;
		document.getElementById("container").appendChild(renderer.view);
		
		// Load spritesheets
		loader.add('res/grasstiles.json')
			.add('res/playerdata.json')
			.add('res/bigtree.png')
			.add('res/goddess.png')
			.add('res/background.png')
			.add('res/cloudscroll.png')
			.add('res/marble.png')
			.load(setup);

		// Set initial game state
		let state = play;
		let screen = 0;

		/*
		 *  setup
		 *
		 *  intitializes sprites, hitboxes, keyboard callbacks
		 */
		let activeScreen;
		let player;

		let tileGroup;
		let keyObjectLeft, keyObjectRight, keyObjectZ, keyObjectX;
		let groundBoxes, hitBoxRenderer;
		let renderHitboxes;
		let backgroundSprite;
		let cloudsSprite;
		function setup() {
			
			let tileTextures = PIXI.loader.resources["res/grasstiles.json"].textures;
			let playerTextures = PIXI.loader.resources["res/playerdata.json"].textures;

			cloudsSprite = new PIXI.extras.TilingSprite(resources['res/cloudscroll.png'].texture, 256, 256);
			cloudsSprite.scale.set(2, 2);
			cloudsSprite.position.set(0, 0);

			hitBoxRenderer = new PIXI.Graphics();
			renderHitboxes = true;

			backgroundSprite = new Sprite(resources["res/background.png"].texture);
			backgroundSprite.scale.set(2, 2);

			player = spawnPlayer(buildPlayer(playerBase_pinkKnight), 256, 320);

			activeScreen = {};
			setActiveScreen(screen);
			renderer.render(activeScreen.stage); 

			keyObjectLeft = keyboard(37);
			keyObjectLeft.press = function() {
				if (player.sprite.scale.x === 1 && keyObjectZ.isDown) {
					player.sprite.vy -= 0.8;
				}

				if (player.controlMode === 'stuck') {
					player.controlMode = 'free';
					player.weaponbox = 0;
				}
			}
			keyObjectRight = keyboard(39);
			keyObjectRight.press = function() {
				if (player.sprite.scale.x === -1 && keyObjectZ.isDown) {
					player.sprite.vy -= 0.8;
				}

				if (player.controlMode === 'stuck') {
					player.controlMode = 'free';
					player.weaponbox = 0;
				}
			}

			keyObjectZ = keyboard(90);
			keyObjectZ.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) attackPlayer(player, 'stab');
					else attackPlayer(player, 'lunge');
				}
			}
			keyObjectZ.release = function() {
				if (!keyObjectX.isDown) {
					player.sprite.loop = false;
					player.sprite.onComplete = function() {
						player.controlMode = 'free';
						setAnimation(player, player.animations.idle);
						player.weaponbox = 0;
					}
				}
			}

			keyObjectX = keyboard(88);
			keyObjectX.press = function() {
				if (player.controlMode === 'free') {
					if (player.grounded) attackPlayer(player, 'slash');
					else attackPlayer(player, 'drill');
				}
			}
			keyObjectX.release = function() {
				if (!keyObjectZ.isDown) {
					player.sprite.loop = false;
					player.sprite.onComplete = function() {
						setAnimation(player, player.animations.idle);
						player.weaponbox = 0;
					}
				}
			}

			keyObjectH = keyboard(72);
			keyObjectH.press = function() {
				renderHitboxes = renderHitboxes ? false : true;
			}


			eventBoxes.forEach(function(set) {
				set.forEach(function(box) {
					buildHitbox(box);
				});
			});
		}

		setAnimation = function(actor, frames, loop=true) {
			if (actor.sprite.textures != frames) {
				actor.sprite.textures = frames;
				actor.sprite.gotoAndPlay(0);
				actor.sprite.updateTexture();
			} 

			actor.sprite.loop = loop;
		}

		moveActor = function(actor, dx, dy) {
			actor.hitbox.centerX += dx;
			actor.hitbox.centerY += dy;

			//actor.sprite.x += dx;
			//actor.sprite.y += dy;

			if (actor.footLine) moveLine(actor.footLine, dx, dy);
		}

		animatePlayer = function() {
			if (player.controlMode === 'free') {
				if (player.weaponbox) {

				} else {
					if (player.grounded) {
						if (player.sprite.vx === 0) setAnimation(player, player.animations.idle);
						else setAnimation(player, player.animations.walk);
					} else {
						setAnimation(player, player.animations.jump);
					}
				}
			} else if (player.controlMode === 'hit') {
				setAnimation(player, player.animations.damage);
			}
		}

		turnPlayer = function() {
			if (keyObjectLeft.isDown) {
				player.sprite.scale.x = -1;

			} else if (keyObjectRight.isDown) {
				player.sprite.scale.x = 1;
			}
		}

		walkPlayer = function() {
			if (keyObjectRight.isDown || keyObjectLeft.isDown) {
				//either left or right is pressed

				if (!keyObjectLeft.isDown) {
					//only right pressed
					player.sprite.vx = 3;
					
				} else if (!keyObjectRight.isDown) {
					//only left pressed
					player.sprite.vx = -3;
					
				} else {
					// Left and right pressed
					player.sprite.vx = 0;

				}
			} else {
				//neither left nor right pressed
				player.sprite.vx = 0;
			}
		}

		controlPlayer = function() {
			if (player.controlMode === 'free') {
				if (player.grounded && player.weaponbox) {
					player.sprite.vx = 0;

				} else {
					walkPlayer();
				}

				turnPlayer();

			} else if (player.controlMode === 'hit') {

				if (player.grounded) {
					player.sprite.vx = 0;
					player.controlMode = 'free';
					setAnimation(player, player.animations.idle);
				}

				if (player.damageTimer < now - 1000) {
					player.controlMode = 'free';
					setAnimation(player, player.animations.idle);
				}
			} else if (player.controlMode === 'stuck') {
				player.sprite.vx = 0;
				player.sprite.vy = 0;

			} else if (player.controlMode === 'attack') {
				if (!player.grounded) {
					walkPlayer();
				}
				if (!keyObjectX.isDown && !keyObjectZ.isDown) {
					player.weaponbox = 0;
					player.controlMode = 'free';
				}

				turnPlayer();
			}

			if (player.vulnerable === false && player.invulnTimer < now - 1000) {
				player.vulnerable = true;
			}
		}

		buildWeaponbox = function(actor, weaponboxBase) {
			let h = {
				name: weaponboxBase.name,

				x: actor.sprite.position.x + weaponboxBase.offsetX * actor.sprite.scale.x,
				y: actor.sprite.position.y + weaponboxBase.offsetY * actor.sprite.scale.y,

				width: weaponboxBase.width * actor.sprite.scale.x,
				height: weaponboxBase.height * actor.sprite.scale.y
			}

			buildHitbox(h);
			return h;
		}

		function buildStage(platforms, playerSprite) {
			
			let tileTextures = PIXI.loader.resources["res/grasstiles.json"].textures;
			let stage = new Container()
			
			stage.addChild(backgroundSprite);
			stage.addChild(cloudsSprite);
			stage.addChild(playerSprite);

			platforms.forEach(function(platform) {
				setPlatformTiles(tileTextures, platform);
				stage.addChild(platform.tileGroup);

				if (platform.type === 'block') {
					buildHitbox(platform.hitbox);
				}
			});
			
			stage.addChild(hitBoxRenderer);

			return stage;
		}

		function checkAttackWall(actor, groundBoxes) {
			if (collisionList = getCollisions(actor.activeWeaponbox, groundBoxes)) return true;
			return false;
		}

		function setActiveScreen(key) {
			screen = key;
			activeScreen.platforms = level_forest.platformGroups[0].platforms;
			activeScreen.stage = buildStage(activeScreen.platforms, player.sprite);
		}

		function play() {

			hitBoxRenderer.clear();
			hitBoxRenderer.lineStyle(1, 0xFF0000);

			/* CLOUD SCROLL */
			cloudsSprite.tilePosition.x -= 0.03;

			if (player.grounded) player.sprite.vy = 0.1;
			player.grounded = false;

			/* MOVE ACTORS */
			movePlayer(player, activeScreen.platforms, player.sprite.vx, player.sprite.vy);

			/* BUILD WEAPON HITBOXES */
			if (player.weaponbox) {
				player.activeWeaponbox = buildWeaponbox(player, player.weaponbox[player.sprite.currentFrame]);
			}

			/* GROUND CHECKS */
			let collision, collisionList;
			activeScreen.platforms.forEach(function(platform) {
				collision = 0;

				if (platform.type === 'platform') {
					if (!player.keyObjectDown.isDown && player.sprite.vy > 0) {
						collision = linesCross(player.footLine, platform);
					}
				} else if (platform.type === 'block') {
					collision = rectangleCollision(player.hitbox, platform.hitbox);
				}

				if (collision) {
						if (platform.tileGroup.children.length > 0) {
							
							activeScreen.stage.removeChild(player.sprite);
							activeScreen.stage.addChildAt(player.sprite, activeScreen.stage.getChildIndex(platform.tileGroup));

							player.activePlatform = platform;
						}

						player.resolveCollision(collision);
					}
			});

			/* GRAVITY */
			if (!player.grounded && !player.stuck) {
				let t = player.jumptimer;

				player.sprite.vy += 0.2 - 0.2 * (player.jumptimer/20);

				if (player.jumptimer > 0) player.jumptimer--;
			}

			/* RENDER HITBOXES */
			if (renderHitboxes) {

				hitBoxRenderer.moveTo(player.footLine.p1.x, player.footLine.p1.y);
				hitBoxRenderer.lineTo(player.footLine.p2.x, player.footLine.p2.y);

				activeScreen.platforms.forEach(function(platform) {
					if (platform.type === 'platform') {
						hitBoxRenderer.moveTo(platform.p1.x - player.hitbox.centerX + 256, platform.p1.y - player.hitbox.centerY + 320);
						hitBoxRenderer.lineTo(platform.p2.x - player.hitbox.centerX + 256, platform.p2.y - player.hitbox.centerY + 320);
					} else if (platform.type === 'block') {
						drawHitbox(platform.hitbox, hitBoxRenderer);
					}
				});

				drawHitbox(player.hitbox, hitBoxRenderer)
				if (player.weaponbox) {
					let box = player.activeWeaponbox;
					hitBoxRenderer.drawRect(box.x, box.y, box.width, box.height);
				}
			}

			/* CONTROL AND ANIMATE PLAYER */
			controlPlayer();
			animatePlayer();
		}

		function gameLoop() {
			now = Date.now();
			timeSinceLastFrame = now - lastTime;

			requestAnimationFrame(gameLoop);
			state();
			renderer.render(activeScreen.stage);

			lastTime = now;
		}

		gameLoop();

	</script>
</body>
</html>
